Authentication 
identity verification

Authorization - access rights either admin or student or normal?(permissions)

JWT (JSON Web Tokens):

JWT is a compact, URL-safe means of representing claims to be transferred between two parties. It can be digitally signed and optionally encrypted.
In a Node.js application, JWTs are often used for stateless authentication. 
When a user logs in, the server creates a JWT containing some user information (such as user ID or role) and signs it using a secret key.
The client receives this JWT and typically stores it in local storage or session storage. On subsequent requests to protected routes,
the client includes the JWT in the request headers.
The server verifies the JWT's signature and decodes its contents to authenticate the user and authorize access to the requested resources.
Since JWTs are self-contained and don't require server-side storage, they're suitable for scaling and distributed systems.

HEADER:ALGORITHM & TOKEN TYPE
{
  "alg": "HS256",
  "typ": "JWT"
}
PAYLOAD - DATA
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
VERIFY SIGNATURE
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  
your-256-bit-secret

)
Encoded
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c


Cookies:

Cookies are small pieces of data stored in the user's browser. They're sent with every request to the server, allowing the server to identify the client.
In Node.js, cookies are often used for session management. When a user logs in, the server creates a session for that user and stores session data on the server.
The server sends a unique session ID to the client in the form of a cookie, which the client includes in subsequent requests.
When a request is received, the server looks up the session ID sent by the client and retrieves the associated session data to authenticate and authorize the user.
Sessions can be stored in memory, in a database, or using a distributed session store like Redis.
In summary, JWTs are commonly used for stateless authentication, while cookies are often used for session-based authentication in Node.js applications.
Both have their advantages and use cases, and the choice between them depends on factors such as scalability, security requirements, and application architecture.


SIGN-UP/LOGIN HANDLERS 

JWT SIGN In
If you read the JWT docs, the function can run in two modes: Synchronously (sync) and asynchronously (async).
The function can automatically decide on which method to use depending on the number of parameters and type of parameters you provide the function,
and the parameters you can supply are (in order):

1 The data/payload
2 Secret key/token
3 Options/configs (optional, can use callback here if you use default options)
4 Callback function (optional, will run in async mode if you provide this)


To illustrate this, read the code below:
// Synchronous
const syncToken = jwt.sign({payload: { x: 1, y: '2'}}, 'JWT_SECRET');
console.log(syncToken);

// Asynchronous
jwt.sign({payload: { x: 1, y: '2'}}, 'JWT_SECRET', (err, asyncToken) => {
  if (err) throw err;
  console.log(asyncToken);
});

// MIDDLEWARES 


// Tokens
Bearer Token:


It is called a bearer token because the bearer of the token (the client) is granted access to the protected resource.
Bearer tokens are typically generated by an authentication server (like OAuth) after successful authentication of the client.
Bearer tokens are generally preferred because they are more secure than other methods like sending tokens in the request body or as cookies. This is because:
They are less susceptible to Cross-Site Request Forgery (CSRF) attacks because they are not automatically included with every request, unlike cookies.
They can be transmitted over secure channels (e.g., HTTPS), making them less prone to interception compared to tokens sent in the request body.
They can be easily invalidated or refreshed without changing the user's credentials.
However, they need to be handled securely on the client side to prevent exposure, such as through XSS attacks.
Body Token:

A body token refers to sending authentication credentials (such as a username and password or a token)
within the request body of an HTTP request.
While it is less common than bearer tokens, it is still used in some authentication schemes.
Sending tokens in the request body has some security implications:
Tokens sent in the request body can be logged by servers, proxies, or any intermediary systems through which the request passes,
potentially exposing them to unauthorized access.
They are more susceptible to CSRF attacks if not accompanied by proper CSRF protection mechanisms.
They may have limitations on how they can be invalidated or refreshed without changing the user's credentials.
Cookie Token:

Sending authentication tokens as cookies involves storing them in the user's browser and including them automatically with subsequent requests to the same domain.
Cookies can be used for session management, including authentication tokens.
However, they are more susceptible to various attacks, such as Cross-Site Scripting (XSS) and Cross-Site Request Forgery (CSRF), if not handled properly.
They may also have limitations in terms of security and manageability compared to bearer tokens.
In summary, bearer tokens are more strongly used than body and cookie tokens because they provide a good balance of security and flexibility. 
They offer advantages such as reduced exposure to CSRF attacks, ease of revocation, and compatibility with secure transmission protocols like HTTPS. 
However, it's essential to handle them securely on the client side to prevent unauthorized access.
